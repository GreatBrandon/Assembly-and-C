     1                                  global _start
     2                                  section .text
     3                                  _start:
     4                                      ; start of program, initalise values
     5 00000000 41B803000000                mov     r8, 3       ; initialise loop to 3
     6 00000006 41BA00000000                mov     r10, 0      ; initialise total sum to 0
     7                                  
     8                                  main_loop:
     9                                      ; main loop
    10 0000000C 41B900000000                mov     r9, 0       ; initialise sum to 0
    11                                      
    12 00000012 48BE-                       mov     rsi, PROMPT ; load address of string into rsi
    12 00000014 [0000000000000000] 
    13 0000001C BA0F000000                  mov     rdx, PROMPT_LEN ; load string length into rdx
    14 00000021 E88E000000                  call    print       ; call print function
    15                                  
    16 00000026 E86D000000                  call    read        ; call read function
    17 0000002B E8B1000000                  call    add_input   ; call add input function to convert input string into hex and add to total
    18                                  
    19 00000030 48BE-                       mov     rsi, PROMPT ; load address of string into rsi
    19 00000032 [0000000000000000] 
    20 0000003A BA0F000000                  mov     rdx, PROMPT_LEN ; load string length into rdx
    21 0000003F E870000000                  call    print       ; call print function
    22                                  
    23 00000044 E84F000000                  call    read        ; call read function
    24 00000049 E893000000                  call    add_input   ; call add input function to convert input string into hex and add to total
    25                                  
    26 0000004E 48BE-                       mov     rsi, RESULT ; load address of string into rsi
    26 00000050 [0F00000000000000] 
    27 00000058 BA0D000000                  mov     rdx, RESULT_LEN ; load string length into rdx
    28 0000005D E852000000                  call    print       ; call print function
    29                                  
    30 00000062 4C89C8                      mov     rax, r9     ; copy the current sum into rax
    31 00000065 E808010000                  call    display_sum ; call display_sum function to convert hex to string output and display it
    32                                      
    33 0000006A 4D01CA                      add     r10, r9     ; add the total of last 2 inputs to final total
    34 0000006D 49FFC8                      dec     r8          ; decrement loop counter
    35 00000070 759A                        jnz     main_loop   ; jump to main_loop if r8 > 0
    36                                  
    37 00000072 48BE-                       mov     rsi, FINAL_RESULT       ; load address of string into rsi
    37 00000074 [1C00000000000000] 
    38 0000007C BA0F000000                  mov     rdx, FINAL_RESULT_LEN   ; load string length into rdx
    39 00000081 E82E000000                  call    print                   ; call print function
    40                                  
    41 00000086 4C89D0                      mov     rax, r10        ; copy the final sum into rax
    42 00000089 E8E4000000                  call    display_sum     ; call display_sum function to convert hex to string output and display it
    43                                  
    44 0000008E B83C000000                  mov     rax, 60     ; system call number for sys_exit
    45 00000093 4831FF                      xor     rdi, rdi    ; clear rdi to get argument 0 (success) on exit
    46 00000096 0F05                        syscall             ; call kernel
    47                                  
    48                                  read:
    49                                      ; read function reads input from terminal and stores in input buffer
    50 00000098 B800000000                  mov     rax, 0      ; system call number for sys_read
    51 0000009D BF00000000                  mov     rdi, 0      ; stdin (console)
    52 000000A2 48BE-                       mov     rsi, input  ; load address of input buffer into rsi
    52 000000A4 [0000000000000000] 
    53 000000AC BA0F000000                  mov     rdx, input_len     ; load length of input buffer into rdx
    54 000000B1 0F05                        syscall             ; call kernel
    55 000000B3 C3                          ret                 ; return
    56                                  
    57                                  print:
    58                                      ; print function prints the current string in rsi and string length in rdx to console
    59 000000B4 B801000000                  mov     rax, 1  ; system call number for sys_write
    60 000000B9 BF01000000                  mov     rdi, 1  ; stdout (console)
    61 000000BE 0F05                        syscall         ; call kernel
    62 000000C0 C3                          ret             ; return
    63                                  
    64                                  println:
    65                                      ; println function does the same as print, however it also prints a CRLF at the end (original rsi and rdx is preserved)
    66 000000C1 E8EEFFFFFF                  call    print   ; call print function
    67 000000C6 56                          push    rsi     ; push rsi to save address
    68 000000C7 52                          push    rdx     ; push rdx to save string length
    69                                  
    70 000000C8 B801000000                  mov     rax, 1  ; system call number for sys_write
    71 000000CD 48BE-                       mov     rsi, CRLF   ; load address of CRLF to rsi
    71 000000CF [2B00000000000000] 
    72 000000D7 BA02000000                  mov     rdx, 2  ; length of CRLF
    73 000000DC 0F05                        syscall         ; call kernel
    74                                  
    75 000000DE 5A                          pop     rdx     ; pop to retrieve stored string length into rdx
    76 000000DF 5E                          pop     rsi     ; pop to retrieve stored string address into rsi
    77 000000E0 C3                          ret             ; return
    78                                  
    79                                  
    80                                  add_input:
    81                                      ; add_input function gets the value stored in input buffer and attempts to add the numerical value to r9
    82                                      ; if input is non numerical (characters other than 0-9) then it will print an error message instead and won't add
    83 000000E1 4883F80F                    cmp     rax, input_len  ; check is the amount of bytes read in the terminal greater than the input buffer
    84 000000E5 7D51                        jge     input_too_long  ; if the input doesn't fit into buffer, jump to this function to prevent buffer overflow vulnerability
    85 000000E7 48BE-                       mov     rsi, input      ; copy input buffer into rsi
    85 000000E9 [0000000000000000] 
    86 000000F1 4831C0                      xor     rax, rax        ; clear rax
    87                                  
    88                                  
    89                                  convert_loop:
    90                                      ; convert_loop handles the logic of converting the string into integer format
    91                                      ; it loops through all characters of the input buffer (most significant to least significant) for each character:
    92                                      ; 1. checks is it valid
    93                                      ; 2. converts it from ascii into numerical
    94                                      ; 3. adds it to the total
    95                                      ; 4. multiply total by 10
    96 000000F4 480FB61E                    movzx   rbx, byte [rsi] ; get the current byte (position) of the string address stored in rsi and copy it to rbx
    97 000000F8 4885DB                      test    rbx, rbx        ; check is rbx = 0
    98 000000FB 7422                        jz      done            ; if equal jump to done
    99                                  
   100 000000FD 4883FB0A                    cmp     rbx, 0x0A       ; check is rbx a newline character (enter key)
   101 00000101 741C                        je      done            ; if equal jump to done
   102                                  
   103 00000103 4883FB30                    cmp     rbx, '0'        ; compare rbx to the ascii value of '0'
   104 00000107 7C1A                        jl      invalid_input   ; if less than 0, jump to invalid input
   105                                  
   106 00000109 4883FB39                    cmp     rbx, '9'        ; compare rbx to the ascii value of '9'
   107 0000010D 7F14                        jg      invalid_input   ; if greater than 9, jump to invalid input
   108                                  
   109                                      ; if character stored in rbx is between 0-9, continue running
   110 0000010F 4883EB30                    sub     rbx, '0'        ; subtract the ascii value of '0' from rbx (e.g. ascii '1' = 49, we want the decimal value 1 so we subtract 48 AKA '0')
   111                                  
   112 00000113 486BC00A                    imul    rax, rax, 10    ; multiply the value of rax by 10 and store the result in rax
   113 00000117 4801D8                      add     rax, rbx        ; add the value in rbx to rax and store result in rax
   114                                  
   115 0000011A 48FFC6                      inc     rsi             ; increment rsi (move to next character in input string)
   116 0000011D EBD5                        jmp     convert_loop    ; loop back to convert loop
   117                                  
   118                                  done:
   119                                      ; done function simply adds the total in rax into r9 and returns
   120 0000011F 4901C1                      add     r9, rax         ; add the value of rax to r9 and store result in r9
   121 00000122 C3                          ret                     ; return
   122                                  
   123                                  invalid_input:
   124                                      ; this function prints an error message to console and returns, preventing anything from being added
   125 00000123 48BE-                       mov     rsi, INVALID_MSG        ; load address of string into rsi
   125 00000125 [2E00000000000000] 
   126 0000012D BA3C000000                  mov     rdx, INVALID_MSG_LENGTH ; load string length into rdx
   127 00000132 E88AFFFFFF                  call    println                 ; call println function
   128 00000137 C3                          ret                             ; return
   129                                  
   130                                  input_too_long:
   131                                      ; this function discards all excess input by reading in buffered input from the terminal byte by byte until the newline has been reached
   132                                      ; this prevents buffer overflow from happening
   133 00000138 B800000000                  mov     rax, 0      ; system call number for sys_read
   134 0000013D BF00000000                  mov     rdi, 0      ; stdin (console)
   135 00000142 48BE-                       mov     rsi, input  ; load address of input buffer into rsi
   135 00000144 [0000000000000000] 
   136 0000014C BA01000000                  mov     rdx, 1      ; read only 1 byte
   137 00000151 0F05                        syscall             ; call kernel
   138                                  
   139 00000153 803C25[00000000]0A          cmp     byte [input], 0xA   ; check has the newline character been reached 
   140 0000015B 75DB                        jne     input_too_long      ; if not continue reading bytes until newline has been reached
   141                                  
   142 0000015D 48BE-                       mov     rsi, TOO_LONG           ; load address of string into rsi
   142 0000015F [6A00000000000000] 
   143 00000167 BA48000000                  mov     rdx, TOO_LONG_LENGTH    ; load length of string into rdx
   144 0000016C E850FFFFFF                  call    println                 ; call println function
   145 00000171 C3                          ret                             ; return
   146                                  
   147                                  display_sum:
   148                                      ; display_sum function displays the current sum stored in rax into console
   149 00000172 48BF-                       mov     rdi, output + output_len    ; copy the address of the last character in the output buffer into rdi
   149 00000174 [2400000000000000] 
   150 0000017C C60700                      mov     byte [rdi], 0               ; place a 0 (null terminator) into the byte at that address in rdi
   151                                  
   152                                  
   153                                  display_loop:
   154                                      ; convert_loop handles the logic of converting the integer into string format
   155                                      ; it continues looping until rax = 0:
   156                                      ; 1. divide rax by 10
   157                                      ; 2. get the remainder and convert into ascii represntation
   158                                      ; 3. copy it into the least significant empty byte of the output buffer (output buffer is filled right to left, least significant to most significant digit)
   159                                      ; 4. decrement the pointer to point to the next more significant byte
   160                                      ; finally it prints the string stored in the output buffer
   161 0000017F 4831D2                      xor     rdx, rdx        ; clear rdx
   162 00000182 BB0A000000                  mov     rbx, 10         ; move 10 into rbx
   163 00000187 48F7F3                      div     rbx             ; divide the value in rax by rbx, result is stored in rax, remainder is stored in dl
   164                                  
   165 0000018A 80C230                      add     dl, '0'         ; add the ascii value of 0 into dl (e.g. 3 in dl add 48 is equal to 52, which is the ascii value of '3')
   166 0000018D 48FFCF                      dec     rdi             ; decrement rdi (i.e. move to the next byte in the output buffer string address stored in rdi)
   167 00000190 8817                        mov     [rdi], dl       ; copy dl into that value in rdi (keyword byte not needed as dl is exactly a byte long)
   168                                  
   169 00000192 4885C0                      test    rax, rax        ; check is the value in rax = 0
   170 00000195 75E8                        jnz     display_loop    ; loop back to display loop if not equal to 0
   171                                  
   172 00000197 48BE-                       mov     rsi, output     ; load address of string into rsi
   172 00000199 [0F00000000000000] 
   173 000001A1 BA15000000                  mov     rdx, output_len ; load string length into rdx
   174 000001A6 E816FFFFFF                  call    println         ; call println function
   175 000001AB C3                          ret                     ; return
   176                                  
   177                                  section .data
   178                                      ; this section stores all initialised constants and variables
   179 00000000 456E746572206E756D-         PROMPT          db  'Enter number: ', 0
   179 00000009 6265723A2000       
   180                                      PROMPT_LEN      equ  $-PROMPT
   181 0000000F 5468652073756D2069-         RESULT          db  'The sum is: ' ,0
   181 00000018 733A2000           
   182                                      RESULT_LEN      equ  $-RESULT
   183 0000001C 46696E616C2073756D-         FINAL_RESULT    db  'Final sum is: ', 0
   183 00000025 2069733A2000       
   184                                      FINAL_RESULT_LEN equ $-FINAL_RESULT
   185 0000002B 0D0A00                      CRLF            db   0x0D, 0x0A, 0
   186                                      CRLF_LEN        equ  $-CRLF
   187 0000002E 496E76616C69642069-         INVALID_MSG     db  'Invalid input! Only 0-9 allowed! Input was replaced with 0!', 0
   187 00000037 6E70757421204F6E6C-
   187 00000040 7920302D3920616C6C-
   187 00000049 6F7765642120496E70-
   187 00000052 757420776173207265-
   187 0000005B 706C61636564207769-
   187 00000064 746820302100       
   188                                      INVALID_MSG_LENGTH equ $-INVALID_MSG
   189 0000006A 496E70757420746F6F-         TOO_LONG        db  'Input too long (only 15 characters allowed)! Input was replaced with 0!', 0
   189 00000073 206C6F6E6720286F6E-
   189 0000007C 6C7920313520636861-
   189 00000085 726163746572732061-
   189 0000008E 6C6C6F776564292120-
   189 00000097 496E70757420776173-
   189 000000A0 207265706C61636564-
   189 000000A9 207769746820302100 
   190                                      TOO_LONG_LENGTH equ  $-TOO_LONG 
   191                                  
   192                                  section .bss
   193                                      ; this section stores all uninitialised constants and variables
   194 00000000 <res Fh>                    input           resb 15     ; reserve 10 bytes for buffer
   195                                      input_len       equ $-input ; length of input buffer
   196 0000000F <res 15h>                   output          resb 21     ; reserve 21 bytes for output buffer (64 bit number never bigger than 21 bytes)
   197                                      output_len      equ $-output    ; length of output buffer
